# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2009-2023, The Zope developer community
# This file is distributed under the same license as the Zope package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Zope 5.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-21 02:36+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../zdgbook/Security.rst:3
msgid "Security"
msgstr ""

#: ../../zdgbook/Security.rst:6
msgid "Introduction"
msgstr ""

#: ../../zdgbook/Security.rst:8
msgid "A typical web application needs to be securely managed.  Different types of users need different kinds of access to the components that make up an application. To this end, Zope includes a comprehensive set of security features.  This chapter's goal is to shed light on Zope security in the context of Zope Product development.  For a more fundamental overview of Zope security, you may wish to refer to the *Zope Book* Chapter `\"Users and Security\" <https://zope.readthedocs.io/en/latest/zopebook/Security.html>`_. Before diving into this chapter, you should have a basic understanding of how to build Zope Products as well as an understanding of how the Zope object publisher works. This is covered in :doc:`ObjectPublishing`."
msgstr ""

#: ../../zdgbook/Security.rst:23
msgid "Security Architecture"
msgstr ""

#: ../../zdgbook/Security.rst:25
msgid "The Zope security architecture is built around a *security policy*, which you can think of as the \"access control philosophy\" of Zope. This policy arbitrates the decisions Zope makes about whether to allow or deny access to any particular object defined within the system."
msgstr ""

#: ../../zdgbook/Security.rst:33
msgid "How The Security Policy Relates to Zope's Publishing Machinery"
msgstr ""

#: ../../zdgbook/Security.rst:35
msgid "When access to Zope is performed via HTTP or WebDAV, Zope's publishing machinery consults the security policy in order to determine whether to allow or deny access to a visitor for a particular object.  For example, when a user visits the root ``index_html`` object of your site via HTTP, the security policy is consulted by ``ZPublisher`` to determine whether the user has permission to view the ``index_html`` object itself."
msgstr ""

#: ../../zdgbook/Security.rst:43
msgid "On top of that, the publisher also defines other rules to determine which objects can be published. The most important of these is that objects which are published must have a docstring."
msgstr ""

#: ../../zdgbook/Security.rst:47
msgid "For more information on this topic, see the chapter on :doc:`ObjectPublishing`."
msgstr ""

#: ../../zdgbook/Security.rst:52
msgid "How The Security Policy Relates to Restricted Code"
msgstr ""

#: ../../zdgbook/Security.rst:54
msgid "*Restricted code* is generally any sort of logic that may be edited remotely (through the Web, via WebDAV or by other means). DTML Methods, SQLMethods, Python Scripts and Page Templates are examples of restricted code."
msgstr ""

#: ../../zdgbook/Security.rst:59
msgid "When restricted code runs, any access to objects integrated with Zope security is arbitrated by the security policy. For example if you write a bit of restricted code with a line that attempts to manipulate an object you don't have sufficient permission to use, the security policy will deny access to the object.  This is accomplished by raising an ``Unauthorized`` exception, which is a Python exception caught by the publisher and handed to a user folder, which will then attempt to get user credentials before continuing with the request.  The particular code used to attempt to obtain the credentials is determined by the User Folder \"closest\" (folder-wise) to the object being accessed."
msgstr ""

#: ../../zdgbook/Security.rst:73
msgid "``Unauthorized`` Exceptions and Through-The-Web Code"
msgstr ""

#: ../../zdgbook/Security.rst:75
msgid "The security policy infrastructure will raise an ``Unauthorized`` exception automatically when access to an object is denied.  When an ``Unauthorized`` exception is raised within Zope, it is handled in a sane way by Zope, generally by having the User Folder prompt the user for login information.  Using this functionality, it's possible to protect Zope objects through access control, only prompting the user for authentication when it is necessary to perform an action which requires privilege."
msgstr ""

#: ../../zdgbook/Security.rst:84
msgid "An example of this behavior can be witnessed within the Zope Management interface itself.  The management interface prompts you to log in when visiting, for example, the ``/manage`` method of any Zope object.  This is due to the fact that an anonymous user is not generally authorized to use the management interface.  If you're using Zope in the default configuration with the default User Folder, it prompts you to provide login information via an HTTP basic authentication dialog."
msgstr ""

#: ../../zdgbook/Security.rst:95
msgid "How The Security Policy Relates To Unrestricted Code"
msgstr ""

#: ../../zdgbook/Security.rst:97
msgid "There are also types of *unrestricted code* in Zope, where the logic is not constrained by the security policy. Examples of unrestricted code are the methods of Python classes that implement the objects in Python filesystem-based add-on components.  Another example of unrestricted code can be found in External Method objects (must be installed separately), which are defined in files on the filesystem. These sorts of code are allowed to run `unrestricted` because access to the file system is required to define such logic.  Zope assumes that code defined on the filesystem is \"trusted\", while code defined \"through the web\" is not.  All filesystem-based code in Zope is unrestricted code."
msgstr ""

#: ../../zdgbook/Security.rst:109
msgid "We'll see later that while the security policy does not constrain what your unrestricted code does, it can and should be used to control the ability to *call* your unrestricted code from within a restricted-code environment."
msgstr ""

#: ../../zdgbook/Security.rst:116
msgid "Details Of The Default Zope Security Policy"
msgstr ""

#: ../../zdgbook/Security.rst:118
msgid "In short, the default Zope security policy ensures the following:"
msgstr ""

#: ../../zdgbook/Security.rst:120
msgid "access to an object which does not have any associated security information is always denied."
msgstr ""

#: ../../zdgbook/Security.rst:123
msgid "access to an object whose name begins with the underscore character ``_`` is always denied."
msgstr ""

#: ../../zdgbook/Security.rst:126
msgid "if the object has a security assertion declaring it *private*, then access will be denied."
msgstr ""

#: ../../zdgbook/Security.rst:129
msgid "if the object has a security assertion declaring it *public* , then access will be granted."
msgstr ""

#: ../../zdgbook/Security.rst:132
msgid "if an object is associated with a permission, access is granted or denied based on the user's roles.  If a user has a role which has been granted the permission in question, access is granted.  If the user does not possess a role that has been granted the permission in question, access is denied."
msgstr ""

#: ../../zdgbook/Security.rst:138
msgid "objects can only be published if they have a doc string. This restriction exists outside the security policy itself."
msgstr ""

#: ../../zdgbook/Security.rst:142
msgid "As we delve further into Zope security within this chapter, we'll see exactly what it means to associate security information with an object."
msgstr ""

#: ../../zdgbook/Security.rst:148
msgid "Overview Of Using Zope Security Within Your Product"
msgstr ""

#: ../../zdgbook/Security.rst:150
msgid "Of course, now that we know what the Zope security policy is, we need to know how our Product can make use of it.  Zope developers leverage the Zope security policy primarily by making security declarations related to methods and objects within their Products.  Using security assertions, developers may deny or allow all types of access to a particular object or method unilaterally, or they may protect access to Zope objects more granularly by using permissions to grant or deny access based on the roles of the requesting user to the same objects or methods."
msgstr ""

#: ../../zdgbook/Security.rst:160
msgid "For a more fundamental overview of Zope users, roles, and permissions, see the section titled \"Authorization, Roles and Permissions\" in the `Security Chapter of the Zope Book <https://zope.readthedocs.io/en/latest/zopebook/Security.html>`_."
msgstr ""

#: ../../zdgbook/Security.rst:167
msgid "Security Declarations In Zope Products"
msgstr ""

#: ../../zdgbook/Security.rst:169
msgid "Zope security declarations allow developers to make security assertions about a Product-defined object and its methods. Security declarations come in three basic forms.  These are:"
msgstr ""

#: ../../zdgbook/Security.rst:173
msgid "public -- allow anybody to access the protected object or method"
msgstr ""

#: ../../zdgbook/Security.rst:176
msgid "private -- deny anyone access to the protected object or method"
msgstr ""

#: ../../zdgbook/Security.rst:179
msgid "protected -- protect access to the object or method with a permission"
msgstr ""

#: ../../zdgbook/Security.rst:182
msgid "We'll see how to actually define these security assertions a little later in this chapter.  In the meantime, just know that security declarations are fundamental to Zope Product security, and they can be used to protect access to an object by associating it with a permission.  We will refer to security declarations as `declarations` and `assertions` interchangeably within this chapter."
msgstr ""

#: ../../zdgbook/Security.rst:192
msgid "Permissions In Zope Products"
msgstr ""

#: ../../zdgbook/Security.rst:194
msgid "A permission is the smallest unit of access to an object in Zope, roughly equivalent to the atomic permissions on files seen in Windows NT or UNIX: R (Read), W(Write), X(Execute), etc. However, unlike these types of mnemonic permissions shared by all sorts of different file types in an operating system product, in Zope, a permission usually describes a fine-grained logical operation which takes place upon an object, such as \"View Management Screens\" or \"Add Properties\"."
msgstr ""

#: ../../zdgbook/Security.rst:203
msgid "Zope administrators associate these permissions with *roles*, which they grant to Zope users.  Thus, declaring a protection assertion on a method of \"View management screens\" ensures that only users who possess roles which have been granted the \"View management screens\" permission are able to perform the action that the method defines."
msgstr ""

#: ../../zdgbook/Security.rst:209
msgid "It is important to note that Zope's security architecture dictates that roles and users remain the domain of administrators, while permissions remain the domain of developers.  Developers of Products should not attempt to define roles or users, although they may (and usually must) define permissions.  Most importantly, a Zope administrator who makes use of your product should have the \"last word\" as regards which roles are granted which permissions, allowing her to protect her site in a manner that fits her business goals."
msgstr ""

#: ../../zdgbook/Security.rst:218
msgid "Permission names are strings, and these strings are currently arbitrary.  There is no permission hierarchy, or list of \"approved permissions\".  Developers are encouraged to reuse Zope core permissions (e.g. \"View\", \"Access contents information\") where appropriate, or they may create their own as the need arises.  It is generally wise to reuse existing Zope permission names unless you specifically need to define your own.  For a list of existing Zope core permissions, see :doc:`AppendixA`."
msgstr ""

#: ../../zdgbook/Security.rst:227
msgid "Permissions are often tied to method declarations in Zope.  Any number of method declarations may share the same permission.  It's useful to declare the same permission on a set of methods which can logically be grouped together.  For example, two methods which return management forms for the object can be provided with the same permission, \"View management screens\".  Likewise, two entirely different objects can share a permission name to denote that the operation that's being protected is fundamentally similar.  For instance, most Product-defined objects reuse the Zope \"View\" permission, because most Zope objects need to be viewed in a web browser.  If you create an addable Zope class named `MyObject`, it doesn't make much sense to create a permission \"View MyObject\", because the generic \"View\" permission may be reused for this action."
msgstr ""

#: ../../zdgbook/Security.rst:241
msgid "There is an exception to the \"developers should not try to define roles\" rule inasmuch as Zope allows developers to assign `default roles` to a permission.  This is primarily for the convenience of the Zope administrator, as default roles for a permission cause the Zope security machinery to provide a permission to a role *by default* when instances of a Product class are encountered during security operations.  For example, if your Product defines a permission \"Add Poll Objects\", this permission may be associated with a set of default roles, perhaps \"Manager\".  Default roles in Products should not be used against roles other than \"Manager\", \"Anonymous\", \"Owner\", and \"Authenticated\" (the four default Zope roles), as other roles are not guaranteed to exist in every Zope installation."
msgstr ""

#: ../../zdgbook/Security.rst:254
msgid "Using security assertions in Zope is roughly analogous to assigning permission bit settings and ownership information to files in a UNIX or Windows filesystem.  Protecting objects via permissions allows developers and administrators to secure Zope objects independently of statements made in application code."
msgstr ""

#: ../../zdgbook/Security.rst:262
msgid "Implementing Security In Python Products"
msgstr ""

#: ../../zdgbook/Security.rst:265
msgid "Security Assertions"
msgstr ""

#: ../../zdgbook/Security.rst:267
msgid "You may make several kinds of security assertions at the Python level.  You do this to declare accessibility of methods and subobjects of your classes. Three of the most common assertions that you'll want to make on your objects are:"
msgstr ""

#: ../../zdgbook/Security.rst:272
msgid "this object is **public** (always accessible)"
msgstr ""

#: ../../zdgbook/Security.rst:274
msgid "this object is **private** (not accessible by restricted code or by URL traversal)"
msgstr ""

#: ../../zdgbook/Security.rst:277
msgid "this object is **protected** by a specific permission"
msgstr ""

#: ../../zdgbook/Security.rst:279
msgid "There are a few other kinds of security assertions that are much less frequently used but may be needed in some cases:"
msgstr ""

#: ../../zdgbook/Security.rst:282
msgid "asserting that access to subobjects that do not have explicit security information should be allowed rather than denied."
msgstr ""

#: ../../zdgbook/Security.rst:285
msgid "asserting what sort of protection should be used when determining access to an *object itself* rather than a particular method of the object"
msgstr ""

#: ../../zdgbook/Security.rst:289
msgid "It is important to understand that security assertions made in your Product code *do not* limit the ability of the code that the assertion protects.  Assertions only protect *access to this code*. The code which constitutes the body of a protected, private, or public method of a class defined in a Zope filesystem-based Product runs completely unrestricted, and is not subject to security constraints of any kind within Zope.  An exception to this rule occurs when filesystem-based-Product code calls a \"through the web\" method such as a Python Script or a DTML Method.  In this case, the security constraints imposed by these objects respective to the current request are obeyed."
msgstr ""

#: ../../zdgbook/Security.rst:303
msgid "When Should I Use Security Assertions?"
msgstr ""

#: ../../zdgbook/Security.rst:305
msgid "If you are building an object that will be used from a Page Template or other restricted code, or that will be accessible directly through the web (or other remote protocols such as WebDAV) then you need to define security information for your object."
msgstr ""

#: ../../zdgbook/Security.rst:312
msgid "Making Security Assertions"
msgstr ""

#: ../../zdgbook/Security.rst:314
msgid "As a Python developer, you make security assertions in your Python classes using ``SecurityInfo`` objects. A ``SecurityInfo`` object provides the interface for making security assertions about an object in Zope."
msgstr ""

#: ../../zdgbook/Security.rst:319
msgid "The convention of placing security declarations inside Python code may at first seem a little strange if you're used to \"plain old Python\" which has no notion at all of security declarations.  But because Zope provides the ability to make these security assertions at such a low level, the feature is ubiquitous throughout Zope, making it easy to make these declarations once in your code, usable site-wide without much effort."
msgstr ""

#: ../../zdgbook/Security.rst:329
msgid "Class Security Assertions"
msgstr ""

#: ../../zdgbook/Security.rst:331
msgid "The most common kind of ``SecurityInfo`` you will use as a component developer is the ``ClassSecurityInfo`` object.  You use ``ClassSecurityInfo`` objects to make security assertions about methods on your classes."
msgstr ""

#: ../../zdgbook/Security.rst:336
msgid "Classes that need security assertions are any classes that define methods that can be called \"through the web\".  This means any methods that can be called directly with URL traversal, from Page templates, DTML Methods, or from Python Script objects."
msgstr ""

#: ../../zdgbook/Security.rst:343
msgid "Declaring Class Security"
msgstr ""

#: ../../zdgbook/Security.rst:345
msgid "When writing the classes in your product, you create a ``ClassSecurityInfo`` instance *within each class that needs to play with the security model*. You then use the ``ClassSecurityInfo`` object to make assertions about your class, its subobjects and its methods."
msgstr ""

#: ../../zdgbook/Security.rst:350
msgid "The ``ClassSecurityInfo`` class is defined in the ``AccessControl`` package of the Zope framework. To declare class security information create a ``ClassSecurityInfo`` class attribute named ``security``.  The name ``security`` is used for consistency and for the benefit of new component authors, who often learn from looking at other people's code. You do not have to use the name ``security`` for the security infrastructure to recognize your assertion information, but it is recommended as a convention."
msgstr ""

#: ../../zdgbook/Security.rst:359
msgid "The ``ClassSecurityInfo`` object can be used to declare access in two ways, as a `function decorator` or by calling the required method explicitly."
msgstr ""

#: ../../zdgbook/Security.rst:362
msgid "For example::"
msgstr ""

#: ../../zdgbook/Security.rst:382
msgid "In the example above we decorated the ``messageCount`` method with the decorator method ``security.public`` of the ``ClassSecurityInfo`` instance to declare that access to the ``messageCount`` method be public. To make security assertions for your object, you just call the appropriate methods of the ``ClassSecurityInfo`` object, passing the appropriate information for the assertion you are making."
msgstr ""

#: ../../zdgbook/Security.rst:389
msgid "The ``ClassSecurityInfo`` approach has a number of benefits. A major benefit is that it is very explicit, it allows your security assertions to appear in your code near the objects they protect, which makes it easier to assess the state of protection of your code at a glance. The ``ClassSecurityInfo`` interface also allows you as a component developer to ignore the implementation details in the security infrastructure and protects you from future changes in those implementation details."
msgstr ""

#: ../../zdgbook/Security.rst:398
msgid "Let's expand on the example above and see how to make the most common security assertions using the ``SecurityInfo`` interface."
msgstr ""

#: ../../zdgbook/Security.rst:401
msgid "To assert that a method is *public* (anyone may call it) you may use the ``public`` decorator::"
msgstr ""

#: ../../zdgbook/Security.rst:408
msgid "To assert that a method is *private* you may use the ``private`` decorator::"
msgstr ""

#: ../../zdgbook/Security.rst:415
msgid "To assert that a method or subobject is *protected* by a particular permission, you use the ``protected`` decorator, passing a permission name::"
msgstr ""

#: ../../zdgbook/Security.rst:422
msgid "If you have lots of methods you want to protect under the same permission, you can pass as many methodNames ase you want to a call to the ``declareProtected`` method::"
msgstr ""

#: ../../zdgbook/Security.rst:429
msgid "Passing multiple names like this works for all of the non-decorator ``declare`` security methods (``declarePublic``, ``declarePrivate``, and ``declareProtected``)."
msgstr ""

#: ../../zdgbook/Security.rst:435
msgid "Deciding To Use Protected vs. Public or Private"
msgstr ""

#: ../../zdgbook/Security.rst:437
msgid "If the method you're making the security declaration against is innocuous, and you're confident that its execution will not disclose private information nor make inappropriate changes to system state, you should declare the method public."
msgstr ""

#: ../../zdgbook/Security.rst:442
msgid "If a method should never be run under any circumstances via traversal or via through-the-web code, the method should be declared private.  This is the default if a method has no security assertion, so you needn't explicitly protect unprotected methods unless you've used ``setDefaultAccess`` to set the object's default access policy to ``allow`` (detailed in *Other Assertions* below)."
msgstr ""

#: ../../zdgbook/Security.rst:450
msgid "If the method should only be executable by a certain class of users, you should declare the method protected."
msgstr ""

#: ../../zdgbook/Security.rst:455
msgid "A Class Security Example"
msgstr ""

#: ../../zdgbook/Security.rst:457
msgid "Let's look at an expanded version of our 'Mailbox' example that makes use of each of these types of security assertions::"
msgstr ""

#: ../../zdgbook/Security.rst:493
msgid "Note the last line in the example.  In order for security assertions to be correctly applied to your class, you must call the global class initializer ``InitializeClass`` for all classes that have security information. This is very important - the global initializer does the \"dirty work\" required to ensure that your object is protected correctly based on the security assertions that you have made. If you don't run it on the classes that you've protected with security assertions, the security assertions will not be effective."
msgstr ""

#: ../../zdgbook/Security.rst:504
msgid "Deciding Permission Names For Protected Methods"
msgstr ""

#: ../../zdgbook/Security.rst:506
msgid "When possible, you should make use of an existing Zope permission within ``protected``/``declareProtected`` assertions.  A list of the permissions which are available in a default Zope installation is available within :doc:`AppendixA`.  When it's not possible to reuse an existing permission, you should choose a permission name which is a verb or a verb phrase."
msgstr ""

#: ../../zdgbook/Security.rst:515
msgid "Object Assertions"
msgstr ""

#: ../../zdgbook/Security.rst:517
msgid "Often you will also want to make a security assertion on the *object itself*. This is important for cases where your objects may be accessed in a restricted environment such as a Page Template or a Python Script. Consider the example Page Template code::"
msgstr ""

#: ../../zdgbook/Security.rst:524
msgid "Here we are trying to call ``some_method``, passing the object ``someObject``. When this is evaluated in the restricted environment, the security policy will attempt to validate access to both ``some_method`` and ``someObject``. We've seen how to make assertions on methods - but in the case of ``someObject`` we are not trying to access any particular method, but rather the *object itself* (to pass it to ``some_method``). Because the security machinery will try to validate access to ``someObject``, we need a way to let the security machinery know how to handle access to the object itself in addition to protecting its methods."
msgstr ""

#: ../../zdgbook/Security.rst:535
msgid "To make security assertions that apply to the *object itself* you call methods on the ``SecurityInfo`` object that are analogous to the three that we have already seen::"
msgstr ""

#: ../../zdgbook/Security.rst:545
msgid "The meaning of these methods is the same as for the method variety, except that the assertion is made on the object itself."
msgstr ""

#: ../../zdgbook/Security.rst:550
msgid "An Object Assertion Example"
msgstr ""

#: ../../zdgbook/Security.rst:552
msgid "Here is the updated 'Mailbox' example, with the addition of a security assertion that protects access to the object itself with the `View Mailbox` permission::"
msgstr ""

#: ../../zdgbook/Security.rst:593
msgid "Other Assertions"
msgstr ""

#: ../../zdgbook/Security.rst:595
msgid "The ``SecurityInfo`` interface also supports the less common security assertions noted earlier in this document."
msgstr ""

#: ../../zdgbook/Security.rst:598
msgid "To assert that access to subobjects that do not have explicit security information should be *allowed* rather than *denied* by the security policy, use::"
msgstr ""

#: ../../zdgbook/Security.rst:604
msgid "This assertion should be used with caution. It will effectively change the access policy to \"allow-by-default\" for all attributes in your object instance (not just class attributes) that are not protected by explicit assertions.  By default, the Zope security policy flatly denies access to attributes and methods which are not mentioned within a security assertion. Setting the default access of an object to \"allow\" effectively reverses this policy, allowing access to all attributes and methods which are not explicitly protected by a security assertion."
msgstr ""

#: ../../zdgbook/Security.rst:615
msgid "``setDefaultAccess`` applies to attributes that are simple Python types as well as methods without explicit protection. This is important because some mutable Python types like ``list`` or ``dict`` can then be modified by restricted code. Setting default access to \"allow\" also affects attributes that may be defined by the base classes of your class, which can lead to security holes if you are not sure that the attributes of your base classes are safe to access."
msgstr ""

#: ../../zdgbook/Security.rst:624
msgid "Setting the default access to \"allow\" should only be done if you are sure that all of the attributes of your object are safe to access, since the current architecture does not support using explicit security assertions on non-method attributes."
msgstr ""

#: ../../zdgbook/Security.rst:631
msgid "What Happens When You Make A Mistake Making ``SecurityInfo`` Declarations?"
msgstr ""

#: ../../zdgbook/Security.rst:633
msgid "It's possible that you will make a mistake when making ``SecurityInfo`` declarations.  For example, it is not legal to declare two conflicting permissions on a method::"
msgstr ""

#: ../../zdgbook/Security.rst:650
msgid "When you make a mistake like this, the security machinery will accept the *first* declaration made in the code and will write an error to the Zope debug log upon encountering the second and following conflicting declarations during class initialization. It's similarly illegal to declare a method both private and public, or to declare a method both private and protected, or to declare a method both public and protected. A similar error will be raised in all of these cases."
msgstr ""

#: ../../zdgbook/Security.rst:659
msgid "Note that Zope *will not* warn you if you misspell the name of a method in a ``declareProtected``, ``declarePublic``, or ``declarePrivate`` call.  For instance, you try to protect the ``index_html`` method with the ``View`` permission and make a mistake, spelling the name ``index_html`` as ``inde_html``, like so::"
msgstr ""

#: ../../zdgbook/Security.rst:672
msgid "You'll need to track down these kinds of problems yourself."
msgstr ""

#: ../../zdgbook/Security.rst:676
msgid "Setting Default Roles For Permissions"
msgstr ""

#: ../../zdgbook/Security.rst:678
msgid "When defining operations that are protected by permissions, one thing you commonly want to do is to arrange for certain roles to be associated with a particular permission *by default* for instances of your object."
msgstr ""

#: ../../zdgbook/Security.rst:683
msgid "For example, say you are creating a *News Item* object. You want ``Anonymous`` users to have the ability to view news items by default; you don't want the site manager to have to explicitly change the security settings for each *News Item* just to give the ``Anonymous`` role ``View`` permission."
msgstr ""

#: ../../zdgbook/Security.rst:689
msgid "What you want as a programmer is a way to specify that certain roles should have certain permissions by default on instances of your object, so that your objects have sensible and useful security settings at the time they are created. Site managers can always *change* those settings if they need to, but you can make life easier for the site manager by setting up defaults that cover the common case by default."
msgstr ""

#: ../../zdgbook/Security.rst:697
msgid "As we saw earlier, the ``SecurityInfo`` interface provided a way to associate methods with permissions. It also provides a way to associate a permission with a set of default roles that should have that permission on instances of your object."
msgstr ""

#: ../../zdgbook/Security.rst:702
msgid "To associate a permission with one or more roles, use the following::"
msgstr ""

#: ../../zdgbook/Security.rst:706
msgid "The *permissionName* argument should be the name of a permission that you have used in your object and *rolesList* should be a sequence (tuple or list) of role names that should be associated with *permissionName* by default on instances of your object."
msgstr ""

#: ../../zdgbook/Security.rst:711
msgid "Note that it is not always necessary to use this method. All permissions for which you did not set defaults using ``setPermissionDefault`` are assumed to have a single default role of ``Manager``.  Notable exceptions to this rule include ``View`` and ``Access contents information``, which always have the default roles ``Manager`` and ``Anonymous``."
msgstr ""

#: ../../zdgbook/Security.rst:718
msgid "The ``setPermissionDefault`` method of the ``SecurityInfo`` object should be called only once for any given permission name."
msgstr ""

#: ../../zdgbook/Security.rst:723
msgid "An Example of Associating Default Roles With Permissions"
msgstr ""

#: ../../zdgbook/Security.rst:725
msgid "Here is our ``Mailbox`` example, updated to associate the ``View Mailbox`` permission with the roles ``Manager`` and ``Mailbox Owner`` by default::"
msgstr ""

#: ../../zdgbook/Security.rst:763
msgid "What Happens When You Make A Mistake Declaring Default Roles?"
msgstr ""

#: ../../zdgbook/Security.rst:765
msgid "It's possible that you will make a mistake when making default roles declarations.  For example, it is not legal to declare two conflicting default roles for a permission::"
msgstr ""

#: ../../zdgbook/Security.rst:784
msgid "When you make a mistake like this, the security machinery will accept the *first* declaration made in the code and will write an error to the Zope debug log about the second and following conflicting declarations upon class initialization."
msgstr ""

#: ../../zdgbook/Security.rst:791
msgid "What Can (And Cannot) Be Protected By Class Security Info?"
msgstr ""

#: ../../zdgbook/Security.rst:793
msgid "It is important to note what can and cannot be protected using the ``ClassSecurityInfo`` interface. First, the security policy relies on *Acquisition* to aggregate access control information, so any class that needs to work in the security policy must have either ``Acquisition.Implicit`` or ``Acquisition.Explicit`` in its base class hierarchy."
msgstr ""

#: ../../zdgbook/Security.rst:800
msgid "The current security policy supports protection of methods and protection of subobjects that are instances. It does *not* currently support protection of simple attributes of basic Python types like ``string``, ``int``, ``list`` or ``dict``. For instance::"
msgstr ""

#: ../../zdgbook/Security.rst:836
msgid "Keep this in mind when designing your classes. If you need simple attributes of your objects to be accessible (say via `TAL` or `DTML`), then you need to use the ``setDefaultAccess`` method of ``SecurityInfo`` in your class to allow this (see the note above about the security implications of this). In general, it is always best to expose the functionality of your objects through methods rather than exposing attributes directly."
msgstr ""

#: ../../zdgbook/Security.rst:844
msgid "Note also that the actual ``ClassSecurityInfo`` instance you use to make security assertions is implemented such that it is *never* accessible from restricted code or through the Web, so no action on the part of the programmer is required to protect it."
msgstr ""

#: ../../zdgbook/Security.rst:851
msgid "Inheritance And Class Security Declarations"
msgstr ""

#: ../../zdgbook/Security.rst:853
msgid "Python inheritance can prove confusing in the face of security declarations."
msgstr ""

#: ../../zdgbook/Security.rst:856
msgid "If a base class which has already been run through ``InitializeClass`` is inherited by a subclass, nothing special needs to be done to protect the base class' methods within the subclass unless you wish to modify the declarations made in the base class.  The security declarations \"filter down\" into the subclass."
msgstr ""

#: ../../zdgbook/Security.rst:862
msgid "On the other hand, if a base class hasn't been run through the global class initializer (``InitializeClass``), you need to proxy its security declarations in the subclass if you wish to access any of its methods within through-the-web code or via URL traversal."
msgstr ""

#: ../../zdgbook/Security.rst:867
msgid "In other words, security declarations that you make using ``ClassSecurityInfo`` objects effect instances of the class upon which you make the declaration. You only need to make security declarations for the methods and subobjects that your class actually *defines*. If your class inherits from other classes, the methods of the base classes are protected by the security declarations made in the base classes themselves. The only time you would need to make a security declaration about an object defined by a base class is if you needed to *redefine* the security information in a base class for instances of your own class. An example below redefines a security assertion in a subclass::"
msgstr ""

#: ../../zdgbook/Security.rst:916
msgid "Class Security Assertions In Non-Product Code (External Methods/Python Scripts)"
msgstr ""

#: ../../zdgbook/Security.rst:920
msgid "The examples in this section use so-called \"External Methods\", which require installing the ``Products.ExternalMethod`` package. Use of that package is discouraged in favor of filesystem-based Product code."
msgstr ""

#: ../../zdgbook/Security.rst:925
msgid "Objects that are returned from Python Scripts or External Methods need to have assertions declared for themselves before they can be used in restricted code.  For example, assume you have an External Method that returns instances of a custom ``Book`` class. If you want to call this External Method from a Page Template, and you'd like your template to be able to use the returned ``Book`` instances, you will need to ensure that your class supports ``Acquisition``, and you'll need to make security assertions on the ``Book`` class and initialize it with the global class initializer (just as you would with a class defined in a Product). For example::"
msgstr ""

#: ../../zdgbook/Security.rst:966
msgid "Note that we *wrap* the book instances by way of their ``__of__`` methods to obtain a security context before returning them."
msgstr ""

#: ../../zdgbook/Security.rst:969
msgid "Note that this particular example is slightly dangerous.  You need to be careful that classes defined in external methods not be made persistent, as this can cause Zope object database inconsistencies. In terms of this example, this would mean that you would need to be careful to not attach the Book object returned from the ``getBooks`` method to a persistent object within the ZODB. See :doc:`ZODBPersistentComponents` for more information.  Thus it's generally a good idea to define the ``Book`` class in a Product if you want books to be persistent.  It's also less confusing to have all of your security declarations in Products."
msgstr ""

#: ../../zdgbook/Security.rst:980
msgid "However, one benefit of the ``SecurityInfo`` approach is that it is relatively easy to subclass and add security assertions to classes that you did not write. For example, in an External Method, you may want to return instances of ``Book`` although ``Book`` is defined in another module out of your direct control. You can still use ``SecurityInfo`` to define security information for the class by using::"
msgstr ""

#: ../../zdgbook/Security.rst:1011
msgid "Module Security Assertions"
msgstr ""

#: ../../zdgbook/Security.rst:1013
msgid "Another kind of ``SecurityInfo`` object you will use as a component developer is the ``ModuleSecurityInfo`` object."
msgstr ""

#: ../../zdgbook/Security.rst:1016
msgid "``ModuleSecurityInfo`` objects do for objects defined in modules what ``ClassSecurityInfo`` objects do for methods defined in classes.  They allow module-level objects (generally functions) to be protected by security assertions.  This is most useful when attempting to allow through-the-web code to ``import`` objects defined in a Python module."
msgstr ""

#: ../../zdgbook/Security.rst:1023
msgid "One major difference between ``ModuleSecurityInfo`` objects and ``ClassSecurityInfo`` objects is that ``ModuleSecurityInfo`` objects cannot be declared `protected` by a permission.  Instead, ``ModuleSecurityInfo`` objects may only declare that an object is `public` or `private`.  This is due to the fact that modules are essentially \"placeless\", global things, while permission protection depends heavily on \"place\" within Zope."
msgstr ""

#: ../../zdgbook/Security.rst:1033
msgid "Declaring Module Security"
msgstr ""

#: ../../zdgbook/Security.rst:1035
msgid "In order to use a filesystem Python module from restricted code such as Python Scripts, the module must have Zope security declarations associated with functions within it.  There are a number of ways to make these declarations:"
msgstr ""

#: ../../zdgbook/Security.rst:1040
msgid "By embedding the security declarations in the target module.  A module that is written specifically for Zope may do so, whereas a module not specifically written for Zope may not be able to do so."
msgstr ""

#: ../../zdgbook/Security.rst:1044
msgid "By creating a wrapper module and embedding security declarations within it.  In many cases it is difficult, impossible, or simply undesirable to edit the target module.  If the number of objects in the module that you want to protect or make public is small, you may wish to simply create a wrapper module.  The wrapper module imports objects from the wrapped module and provides security declarations for them."
msgstr ""

#: ../../zdgbook/Security.rst:1052
msgid "By placing security declarations in a filesystem Product. Filesystem Python code, such as the ``__init__.py`` of a Product, can make security declarations on behalf of an external module.  This is also known as an \"external\" module security info declaration."
msgstr ""

#: ../../zdgbook/Security.rst:1057
msgid "The ``ModuleSecurityInfo`` class is defined in the ``AccessControl`` package of the Zope framework."
msgstr ""

#: ../../zdgbook/Security.rst:1062
msgid "Using ModuleSecurityInfo Objects"
msgstr ""

#: ../../zdgbook/Security.rst:1064
msgid "Instances of ``ModuleSecurityInfo`` are used in two different situations.  In embedded declarations, inside the module they affect.  And in external declarations, made on behalf of a module which may never be imported."
msgstr ""

#: ../../zdgbook/Security.rst:1071
msgid "Embedded ModuleSecurityInfo Declarations"
msgstr ""

#: ../../zdgbook/Security.rst:1073
msgid "An embedded ModuleSecurityInfo declaration causes an object in its module to be importable by through-the-web code."
msgstr ""

#: ../../zdgbook/Security.rst:1076
msgid "Here's an example of an embedded declaration::"
msgstr ""

#: ../../zdgbook/Security.rst:1088
msgid "When making embedded ``ModuleSecurityInfo`` declarations, you should instantiate a ``ModuleSecurityInfo`` object and assign it to a name. It's wise to use the recommended name ``modulesecurity`` for consistency's sake.  You may then use the ``modulesecurity`` object's ``declarePublic`` method to declare functions inside of the current module as `public`.  Finally, appending the last line (``modulesecurity.apply(globals())``) is an important step.  It's necessary in order to poke the security machinery into action.  The above example declares the ``foo`` function public."
msgstr ""

#: ../../zdgbook/Security.rst:1098
msgid "The name ``modulesecurity`` is used for consistency and for the benefit of new component authors, who often learn from looking at other people's code.  You do not have to use the name ``modulesecurity`` for the security infrastructure to recognize your assertion information, but it is recommended as a convention."
msgstr ""

#: ../../zdgbook/Security.rst:1106
msgid "External ModuleSecurityInfo Declarations"
msgstr ""

#: ../../zdgbook/Security.rst:1108
msgid "By creating a ``ModuleSecurityInfo`` instance with a module name argument, you can make declarations on behalf of a module without having to edit or import the module."
msgstr ""

#: ../../zdgbook/Security.rst:1112
msgid "Here's an example of an external declaration::"
msgstr ""

#: ../../zdgbook/Security.rst:1118
msgid "This declaration will cause the following code to work within Python Scripts::"
msgstr ""

#: ../../zdgbook/Security.rst:1123
msgid "When making external ``ModuleSecurityInfo`` declarations, you needn't use the ``modulesecurity.apply(globals())`` idiom demonstrated in the embedded declaration section above.  As a result, you needn't assign the ``ModuleSecurityInfo`` object to the name ``modulesecurity``."
msgstr ""

#: ../../zdgbook/Security.rst:1130
msgid "Providing Access To A Module Contained In A Package"
msgstr ""

#: ../../zdgbook/Security.rst:1132
msgid "Note that if you want to provide access to a module inside of a package which lives in your ``PYTHONPATH``, you'll need to provide security declarations for *all of the the packages and sub-packages along the path used to access the module.*"
msgstr ""

#: ../../zdgbook/Security.rst:1137
msgid "For example, assume you have a function ``foo``, which lives inside a module named ``module``, which lives inside a package named ``package2``, which lives inside a package named ``package1`` You might declare the ``foo`` function public via this chain of declarations::"
msgstr ""

#: ../../zdgbook/Security.rst:1146
msgid "Note that in the code above we took the following steps:"
msgstr ""

#: ../../zdgbook/Security.rst:1148
msgid "make a ``ModuleSecurityInfo`` object for ``package1``"
msgstr ""

#: ../../zdgbook/Security.rst:1150
msgid "call the ``declarePublic`` method of the ``package1`` ``ModuleSecurityInfo`` object, specifying ``package2`` as what we're declaring public.  This allows through the web code to \"see\" ``package2`` inside ``package1``."
msgstr ""

#: ../../zdgbook/Security.rst:1155
msgid "make a ``ModuleSecurityInfo`` object for ``package1.package2``."
msgstr ""

#: ../../zdgbook/Security.rst:1157
msgid "call the ``declarePublic`` method of the ``package1.package2``' ``ModuleSecurityInfo`` object, specifying ``module`` as what we're declaring public.  This allows through the web code to \"see\" ``package1.package2.module``."
msgstr ""

#: ../../zdgbook/Security.rst:1162
msgid "declare ``foo`` public inside the ``ModuleSecurityInfo`` for ``package1.package2.module``."
msgstr ""

#: ../../zdgbook/Security.rst:1165
msgid "Through-the-web code may now perform an import ala: ``import package1.package2.module.foo``"
msgstr ""

#: ../../zdgbook/Security.rst:1170
msgid "Declaring Module Security On Modules Implemented In C"
msgstr ""

#: ../../zdgbook/Security.rst:1172
msgid "Certain modules, such as the standard Python ``sha`` module, provide extension types instead of classes, as the ``sha`` module is implemented in C. Security declarations typically cannot be added to extension types, so the only way to use this sort of module is to write a Python wrapper class, or use `External Methods`."
msgstr ""

#: ../../zdgbook/Security.rst:1180
msgid "Default Module Security Info Declarations"
msgstr ""

#: ../../zdgbook/Security.rst:1182
msgid "Through-the-web Python Scripts are by default able to import a small number of Python modules for which there are security declarations. These include ``string``, ``math``, and ``random``. The only way to make other Python modules available for import is to add security declarations to them in the filesystem."
msgstr ""

#: ../../zdgbook/Security.rst:1190
msgid "Utility Functions For Allowing Import of Modules By Through The Web Code"
msgstr ""

#: ../../zdgbook/Security.rst:1192
msgid "Instead of manually providing security declarations for each function in a module, the utility function ``allow_class`` and ``allow_module`` have been created to help you declare the entire contents of a class or module as public."
msgstr ""

#: ../../zdgbook/Security.rst:1197
msgid "You can handle a module, such as ``base64``, that contains only safe functions by writing ``allow_module('module_name')``.  For instance::"
msgstr ""

#: ../../zdgbook/Security.rst:1203
msgid "This statement declares all functions in the ``base64`` module ( ``encode``, ``decode``, ``encodestring``, and ``decodestring``) as public, and from a script you will now be able to perform an import statement such as ``from base64 import encodestring``."
msgstr ""

#: ../../zdgbook/Security.rst:1209
msgid "To allow access to only some names in a module, you can eschew the ``allow_class`` and ``allow_module`` functions for the lessons you learned in the previous section and do the protection \"manually\"::"
msgstr ""

#: ../../zdgbook/Security.rst:1218
msgid "Making Permission Assertions On A Constructor"
msgstr ""

#: ../../zdgbook/Security.rst:1220
msgid "When you develop a Python filesystem-based product, you will generally be required to make \"constructor\" methods for the objects which you wish to make accessible via the Zope management interface by users of your Product.  These constructors are usually defined within the modules which contain classes which are intended to be turned into Zope instances.  For more information on how constructors are used in Zope with security, see the chapter :doc:`Products`."
msgstr ""

#: ../../zdgbook/Security.rst:1228
msgid "The Zope Product machinery \"bootstraps\" Product-based classes with proper constructors into the namespace of the Zope management interface `Add` list at Zope startup time.  This is done as a consequence of registering a class by way of the Product's ``__init__.py`` ``initialize`` function.  If you want to make, for example, the imaginary ``FooClass`` in your Product available from the `Add` list, you may construct an ``__init__.py`` file that looks much like this::"
msgstr ""

#: ../../zdgbook/Security.rst:1249
msgid "The line of primary concern to us above is the one which says ``permission='Add FooClasses``.  This is a permission declaration which, thanks to Zope product initialization, restricts the adding of FooClasses to those users who have the `Add FooClasses` permission by way of a role association determined by the system administrator."
msgstr ""

#: ../../zdgbook/Security.rst:1255
msgid "If you do not include a ``permission`` argument to ``registerClass``, then Zope will create a default permission named `Add [meta-type]s`. So, for example, if your object had a meta_type of ``Animal``, then Zope would create a default permission, `Add Animals`.  For the most part, it is much better to be explicit then to rely on Zope to take care of security details for you, so be sure to specify a permission for your object."
msgstr ""

#: ../../zdgbook/Security.rst:1265
msgid "Designing For Security"
msgstr ""

#: ../../zdgbook/Security.rst:1267
msgid "\"Security is hard.\" -- Jim Fulton."
msgstr ""

#: ../../zdgbook/Security.rst:1269
msgid "When you're under a deadline, and you \"just want it to work\", dealing with security can be difficult.  As a component developer, following these basic guidelines will go a long way toward avoiding problems with security integration. They also make a good debugging checklist!"
msgstr ""

#: ../../zdgbook/Security.rst:1274
msgid "Ensure that any class that needs to work with security has ``Acquisition.Implicit`` or ``Acquisition.Explicit`` somewhere in its base class hierarchy."
msgstr ""

#: ../../zdgbook/Security.rst:1278
msgid "Design the interface to your objects around methods; don't expect clients to access instance attributes directly."
msgstr ""

#: ../../zdgbook/Security.rst:1281
msgid "Ensure that all methods meant for use by restricted code have been protected with appropriate security assertions."
msgstr ""

#: ../../zdgbook/Security.rst:1284
msgid "Ensure that you called the global class initializer on all classes that need to work with security."
msgstr ""

#: ../../zdgbook/Security.rst:1289
msgid "Using The RoleManager Base Class With Your Zope Product"
msgstr ""

#: ../../zdgbook/Security.rst:1291
msgid "After your Product is deployed, system managers and other users of your Product often must deal with security settings on instances they make from your classes."
msgstr ""

#: ../../zdgbook/Security.rst:1295
msgid "Product classes which inherit Zope's standard ``RoleManager`` base class allow instances of the class to present a security interface. This security interface allows managers and developers of a site to control an instance's security settings via the Zope management interface."
msgstr ""

#: ../../zdgbook/Security.rst:1301
msgid "The user interface is exposed via the *Security* management view. From this view, a system administrator may secure instances of your Product's class by associating roles with permissions and by asserting that your object instance contains `local roles`.  It also allows them to create `user-defined roles` within the Zope management framework in order to associate these roles with the permissions of your product and with users.  This user interface and its usage patterns are explained in more detail within the `Zope Book's security chapter <https://zope.readthedocs.io/en/latest/zopebook/Security.html>`_."
msgstr ""

#: ../../zdgbook/Security.rst:1311
msgid "If your Product's class does not inherit from ``RoleManager``, its methods will still retain the security assertions associated with them, but you will be unable to allow users to associate roles with the permissions you've defined respective to instances of your class. Your objects will also not allow local role definitions.  Note that objects which inherit from many of the built-in classes such as ``OFS.SimpleItem.SimpleItem`` or ``OFS.ObjectManager.ObjectManager`` already inherit from ``RoleManager``."
msgstr ""

#: ../../zdgbook/Security.rst:1322
msgid "Conclusion"
msgstr ""

#: ../../zdgbook/Security.rst:1324
msgid "Zope security is based upon roles and permissions. Users have roles. Security policies map permissions to roles. Classes protect methods with permissions. As a developer your main job is to protect your classes by associating methods with permissions. Of course there are many other details such as protecting modules and functions, creating security user interfaces, and initializing security settings."
msgstr ""
